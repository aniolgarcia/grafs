 %% LyX 2.1.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[catalan, a4, 12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage[catalan]{babel}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{graphics, graphicx}
\usepackage{tikz, tkz-graph}
\usepackage{pgfplots}
\usepackage{graphviz, tkz-berge}
\usepackage{pstricks, pst-node, pst-tree}
\usepackage[ruled, boxed]{algorithm2e}
\usepackage[a4paper]{geometry}
\usepackage{float}
\usepackage{verbatim}
\usepackage{cancel}
\usepackage[position=top]{subfig}
\usetikzlibrary{arrows,%
                petri,%
                topaths}%
\usetikzlibrary{shapes}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning,automata}

\newenvironment{algorisme}[1][htb]
  {\renewcommand{\algorithmcfname}{Algorisme}% Canviem Algorithm a Algorisme
   \begin{algorithm}[#1]%
  }{\end{algorithm}}
  
\newcommand{\important}[1]{%
  \colorbox{green!25}{$\displaystyle#1$}}
    
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\SetKwProg{Fn}{Funció}{}

\newcounter{propietat}[subsection]
\newenvironment{propietat}[1][]{\refstepcounter{propietat}\par\medskip
  \noindent \textbf{Propietat~\thepropietat #1} \rmfamily}
   {\medskip}


\makeatletter
\tikzset{looop/.style =  {to path={
  \pgfextra{\let\tikztotarget=\tikztostart}
  [looseness=12,min distance=10mm]
  \tikz@to@curve@path},font=\sffamily\small
  }}  







\begin{document}



\part{Introducció a la teoria de grafs}

Aquest primer apartat consisteix en la part més teòrica del treball.
Explicaré breument la història d'aquesta branca de la matemàtica i
posteriorment ens endinsarem en la teoria de grafs com a tal. La teoria
de grafs pot semblar bastant abstracta i, a vegades, complicada d'entendre,
però estarà acompanyada de demostracions i exemples propis que pretenen
facilitar el seguiment del treball. 


\section{Història del grafs}


\subsection{Els primers passos}

Tot sovint, les noves branques de la matemàtica sorgeixen de cercar solucions
a problemes. Problemes que no poden ser resolts ni demostrats amb
el que coneixem i que forcen a desenvolupar nous mètodes i teories.
La teoria de grafs no n'és una excepció i tot seguit presentaré els
problemes que van forjar la creació d'aquesta branca.


\subsubsection*{Euler i els ponts de Königsberg}

La teoria de grafs neix a partir de la solució d'un problema curiós: el problema dels ponts de Königberg (l'actual Kaliningrad, Rússia). El planteig del problema és el següent:
\begin{quote}
\emph{``El riu Pregel divideix Königsberg en quatre parts separades,
i connectades per set ponts. És possible caminar per la ciutat passant
per tots els ponts tan sols una vegada?''}
\end{quote}
Els ciutadans de Königsberg sabien que no era possible, però mai ningú ho havia demostrat fins que Leonhard Euler ho va fer. La demostració de que això no era possible queda recollida en el \emph{``Solutio problematis ad geometriam situs pertinentis}'' publicat el 1736, i l'article també va ser inclòs en el volum 8 de
\emph{``Commentarii Academiae Scientiarum Imperialis Petropolitanae''
}publicat el 1741. En aquest text, Euler diu el següent:
\begin{quote}

\emph{"A més d'aquella part de la geometria que s'ocupa de les quantitats, la qual sempre ha generat un interés preferent, hi ha una altra part -encara pràcticament desconeguda- que ja fou esmentada per Leibniz amb el nom de geometria de posició. Aquesta part de la geometria estudia tot allò que pot ésser determinat únicament per la posició, així com les propietats de la posició; en aquest camp hom no hauria de preocupar-se de quantitats ni de com obtenir-les. No obstant això, els tipus de problemes que pertanyen a aquesta geometria de posició i els mètodes usats per resoldre'ls encara no són suficientment definits. Així doncs, quan darrerement se'm va plantejar un problema que semblava bàsicament geomètric, però que no demanava l'obtenció de quantitats ni admetia una sol·lució basada en el càlcul de quantitats, em vaig adonar que pertanyia a la geometria de posició, sobretot perquè només es podia usar la posició per resolde'l, mentre que el càlcul es mostrava inútil. Així, he decidit exposar ací, com a mostra de la geometria de posició, el mètode que he deduït per a resoldre problemes d'aquesta mena."}
\end{quote}

%Afegir mapa geogràfic dels ponts de Königsberg

Per aconseguir demostrar que el problema no tenia sol·lució, Euler va haver
de representar el problema com un mapa topològic, posant les masses
de terra com a punts i els ponts com a segments que unien aquests
punts, i creant d'aquesta manera el primer graf de la història. Aquest
resulat es considera el primer en teoria de grafs ja que conté un
important teorema d'aquesta branca. A més d'iniciar la teoria de grafs,
amb aquest resultat també comença l'estudi dels grafs planars, introdueix
el concepte de característica d'Euler de l'espai i el teorema de poliedres
d'Euler (teorema que després va utilitzar per demostrar que no hi
havia mes sòlids regulars que els sòlids platònics). Amb tot això,
Euler posa les bases, no tan sols de l'estudi dels grafs, sinó també
de la topologia, una altra branca que també serà tractada en aquest
treball. 

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.75,transform shape]
  \Vertex[x=0,y=0]0
  \Vertex[x=0,y=2]1
  \Vertex[x=0,y=4]2
  \Vertex[x=5,y=2]3
  \tikzstyle{LabelStyle}=[fill=white,sloped]
  \Edge(1)(3)
  \tikzstyle{EdgeStyle}=[bend left]
  \Edge(0)(1)
  \Edge(1)(2)
  \Edge(2)(3)
  \tikzstyle{EdgeStyle}=[bend right]
  \Edge(0)(1)
  \Edge(1)(2)
  \Edge(0)(3)
\end{tikzpicture}
\caption{Representació topològica dels ponts de Königsberg}
\end{figure}



\subsubsection*{Vandermonde i el tour del cavall d'escacs}

A partir de l'article d'Euler, diversos matemàtics van començar a
interessar-se pel camp de la topologia (o geometria de la posició,
com li deien en aquell moment). Un d'ells fou Alexandre-Théophile Vandermonde. Vandermonde va treballar i estudiar el problema dels cavalls, que pregunta quins moviments hem de fer per tal que un cavall passi per totes les caselles del tauler d'escacs, problema que també va tractar Euler. Els estudis que Vandermonde va fer sobre aquest problema van ser publicats el 1771 en el \emph{''Remarques sur des problèmes de situation''}, i per la relativa proximitat als treballs d'Euler, encara no parlava de grafs, tot i que en l'actualitat el problema es resol mitjançant aquests. Aquest treball inicia l'estudi de la teoria de nusos, una altra branca de la topologia. 


\subsection{Les primeres descobertes i aplicacions}

Un cop establert l'inici, és difícil veure com va continuar desesenvolupant-se la teoria, ja que en els primers treballs es volien resoldre problemes concrets sense establir relacions entre ells. Tot i així, durant el segle XIX es van plantejar una gran qüantitat de problemes i es van desenvolupar molts teoremes referents els grafs.


\subsubsection*{Francis Guthrie}

El 1852, Francis Guthrie, matemàtic britànic, es planteja el següent problema mentre intenta pintar un mapa del Regne Unit:
\begin{quote}
\emph{``És possible pintar qualsevol mapa de països de tal manera
que un país tingui un color diferent al de tots els seus veïns, utilitzant
tan sols quatre colors?''}
\end{quote}
D'aquest problema en surt el teorema a partir del qual s'sestableix que qualsevol mapa pot ser pintat únicament amb quatre colors diferents, de tal manera que dues regions adjacents (entenem com a adjacents dues regions que comparteixiin frontera, no tan sols un punt) no tinguin colors iguals. Aquest problema, que pot semblar tan trivial, no va ser demostrat fins l'any 1976. Va passar
per mans de pioners com De Morgan, Hamilton, Cayley, Kempe (que
va fer una demostració publicada el 1879), Heawood (que va concloure que la demostració de Kempe no era correcta)... Finalment el 1976
Appel i Hanken van demostrar, mitjançant un programa d'ordinador, que
tot mapa es podia pintar només amb quatre colors. Pel fet de basar-se en un programa d'ordinador, no va acabar de convèncer la demostració. Així doncs, aquest problema no va ser solucionat de manera formal fins l'any 1996 quan, recorrent a la teoria de grafs ja desenvolupada, Neil Robertson, Daniel P. Anders, Paul Seymour i Robin Thomas van publicar-ne un demostració. En els treballs d'Appel i Hanken es van definir alguns dels conceptes i fonaments de l'actual teoria de grafs. 


\subsubsection*{Arthur Cayley}

Arthur Cayley, matemàtic que treballava en la teoria de grups, topologia
i combintòria, també va aportar una gran quantitat de coneixement a la teoria de grafs. Va treballar amb grafs de tipus arbre i va desenvolupar
la fòrmula $n^{n-2}$, que determina el nombre d'arbres expansius
que té un graf complet de $n$ vèrtex (veure apartat \ref{sec:Complets}). Una fórmula semblant apareixia
en treballs de Carl Wilhelm Borchardt, en els quals Cayley es va basar
i va extendre, tot i que el que actualment dóna nom a la fórmula és el
mateix Cayley. 

També va treballar en el desenvolupament d'una representació de l'estructura
abstracta d'un grup, creant els grafs de Cayley i el teorema de Cayley. Finalment va contribuir també, l'any 1857, en la representació i ennumeració dels isòmers alcans (composts químics que comparteixen fórmula o composició però tenen diferent estructura molecular), representant cada compost mitjançant un graf de tipus arbre. Tot i això, Cayley no només va ser actiu en teoria de grafs, sinó que també va desenvolupar teoremes en àlgebra lineal, topologia i geometria.


\subsubsection*{William Hamilton i Thomas Kirkman }

William Rowan Hamilton va plantejar un problema el 1859 que consistia
a trobar un camí que passés pels 20 vèrtex d'un dodecàedre una sola
vegada a través de les seves arestes. Hamilton va comercialitzar
el joc sota el nom de ``The Icosian game'' (és important dir que
el nom de icosian no va ser degut a que utilitzés un icosaedre, sinó
que feia referència als 20 vèrtexs del dodecaedre per on s'havia de
passar). Entorn aquest joc existeix un gran controvèrsia, ja que Euler anteriorment havia plantejat un problema semblant mentre estudiava el problema dels cavalls d'escacs, i Kirkman va plantejar exactament el mateix problema que Hamilton a la Royal Society un temps abans. 


\subsubsection*{Gustav Kirchhoff}

Gustav Kirchhoff, conegut majoritàriament en el camp de l'electrotècnia
per les lleis de Kirchhoff, també va fer aportacions importants
a la teoria de grafs. Les seves lleis, publicades el 1874, es basen
en la teoria de grafs, però a més, va ser el primer d'utilitzar els
grafs en aplicacions industrials. Va estudiar sobretot els grafs de
tipus arbre i, amb l'investigació que va dur a terme sobre aquest
tipus de grafs, va formular el teorema de Kirchhoff, referent al nombre
d'arbres d'expansió que es poden trobar en un graf. Aquest teorema
es considera una generalització de la fórmula de Cayley.


\subsection{Teoria de grafs moderna}

Durant el segle XX, la teoria de grafs es va continuar desenvolupant.
Amb les bases ja establertes durant el segle XIX, els matemàtics hi
van començar a treballar i el 1936 Dénes König va escriure el primer
llibre de teoria de grafs. Frank Harary va escriure un altre llibre
el 1969, fent més accessible la teoria de grafs. El desenvolupament de l'informàtica i les noves tècniques de computació van permetre treballar amb grafs a molt més gran escala, fent possible, per exemple, la ja citada primera demostració del teorema dels quatre colors per Appel i Hanken. 

Actualment la teoria de grafs és una part molt important de la matemàtica
discreta i està relacionada amb molts àmbits diferents, com per exemple
la topologia, la combinatòria, la teoria de grups, la geometria algebraica...
Des del seu desenvolupament s'han utilitzat els grafs per resoldre
i representar de manera visual problemes en aquests camps. Té aplicacions
en molts altres àmbits com per exemple la computació, la informàtica,
la física, la química, l'electrònica, les telecomunicacions, la biologia,
la logística i fins i tot en l'àmbit econòmic. 

\section{Principis bàsics}

Un \textit{graf} $G=(V,E)$ es defineix com un conjunt de \textit{vèrtexs} (o nodes)
$V=\{v_{1},v_{2},...,v_{n}\}$ i un conjunt d'\textit{arestes} $E=\{e_{1},e_{2},...,e_{m}\}$, cadascuna de les quals uneix dos vèrtex de $V$. Si $v_{i}$ i $v_{j}$, amb $v_{i},v_{j}\in V$, estan units per l'aresta $e_{k}$ escriurem $e_{k}=\{v_{i},v_{j}\}$. Quan volguem especificar el graf concret empararem les notacions $V(G)$ i $E(G)$.
Així doncs un graf està format per un conjunt de punts i un conjunt
d'arestes que uneixen alguns d'aquests punts. El nombre de vèrtexs
d'un graf queda determinat pel nombre d'elements que hi ha en el conjunt
$V$, per tant ens referirem a ell com a $|V|$ (cardinal de $V$).
Amb les arestes passa el mateix, i també utilitzarem $|E|$ per indicar
el nombre d'arestes d'un graf. Definim també que dos vèrtexs són \textit{adjacents} si estàn units per una aresta i, com a conseqüència, són \textit{incidents} a l'aresta. 
\\
La idea intuitiva de graf convida a utilitzar representacions gràfiques. Així, en la figura \ref{fig:exemple} es mostra un graf simple $G$ format
per:
\begin{itemize}
\item $V=\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6}\}$
\item $E=\{\{v_{1},v_{2}\},\{v_{1},v_{4}\},\{v_{1},v_{5}\},\{v_{2},v_{5}\},\{v_{3},v_{4}\},\{v_{3},v_{5}\},\{v_{3},v_{6}\},\{v_{4},v_{6}\}\}$


\end{itemize}

\begin{figure}[H]
\centering
	\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum size=2mm}, transform shape]
		\node[round] (a) at (0,4) {$v_{1}$};
		\node[round] (b) at (0,0) {$v_{2}$};
		\node[round] (c) at (4,0) {$v_{3}$};
		\node[round] (d) at (4,4) {$v_{4}$};
		\node[round] (e) at (2,2) {$v_{5}$};
		\node[round] (f) at (6,2) {$v_{6}$};
		\draw (a) edge (b);
		\draw (a) edge (d);
		\draw (a) edge (e);
		\draw (b) edge (e);
		\draw (c) edge (d);
		\draw (c) edge (e);
		\draw (c) edge (f);
		\draw (d) edge (f);
	\end{tikzpicture}
\caption{Representació gràfica del graf $G=(V,E)$ que s'ha presentat}
\label{fig:exemple}
\end{figure}


Si una aresta comença i acaba en el mateix vèrtex (per exemple $e_{m}=\{v_{i},v_{i}\}$
s'anomena llaç (figura \ref{fig:exemples_tipus}, cas (a)). També pot ser que hi hagi dues arestes idèntiques,
és a dir, dues arestes que uneixin $v_{i}$ i $v_{j}$ (figura \ref{fig:exemples_tipus}, cas (b)). En qualsevol d'aquests dos casos anteriors,
el graf s'anomena \textit{multigraf} o \textit{pseudograf}. En cas contrari, el graf
serà anomenat \textit{simple}. Amb el que hem vist fins ara, podem dir que
$e_{1}=\{v_{1},v_{2}\}$ és equivalent a $e_{2}=\{v_{2},v_{1}\}$ (ja que es tracta de parells no ordenats). Tanmateix, existeixen grafs en els quals les arestes han de ser recorregudes en una direcció determinada. S'anomenen grafs \textit{dirigits} i, en aquest cas, si $e_{1}=(v_{1},v_{2})$ i $e_{2}=(v_{2},v_{1})$, $e_{1}\neq e_{2}$, ja que es tracta de parells ordenats (figura \ref{fig:exemples_tipus}, cas (c)). En la següent imatge
es mostren els grafs esmentats anteriorment:


\begin{figure}[H]
\centering
	\subfloat[]{
		\begin{tikzpicture}[round/.style={circle, draw=black, fill=black, thin, minimum size=1mm}, transform shape]
			\node[round] (a) at (0,0){};
			\node[round] (b) at (0,2) {};
			\node[round] (c) at (2,0) {};
			\node[round] (d) at (2,2) {};
			\draw (a) edge (b);
			\draw (a) edge (c);
			\draw (b) edge (d);
			\draw (d) edge (c);
			\draw (a) edge [looop] (a);

		\end{tikzpicture}
	}
	\subfloat[]{
		\begin{tikzpicture}[round/.style={circle, draw=black, fill=black, thin, minimum size=1mm}, transform shape]
			\node[round] (a) at (0,0){};
			\node[round] (b) at (0,2) {};
			\node[round] (c) at (2,0) {};
			\node[round] (d) at (2,2) {};
			\draw (a) edge [bend left](b);
			\draw (a) edge [bend right](b);
			\draw (a) edge [bend left](c);
			\draw (a) edge [bend right](c);
			\draw (b) edge (d);
			\draw (d) edge (c);
		\end{tikzpicture}
	}
	\subfloat[]{
		\begin{tikzpicture}[round/.style={circle, draw=black, fill=black, thin, minimum size=1mm}, transform shape]
			\node[round] (a) at (0,0){};
			\node[round] (b) at (0,2) {};
			\node[round] (c) at (2,0) {};
			\node[round] (d) at (2,2) {};
			\draw (a) edge[->, -Latex] (b);
			\draw (c) edge[->, -Latex] (a);
			\draw (b) edge[->, -Latex] (d);
			\draw (c) edge[->, -Latex] (d);
		\end{tikzpicture}
	}
\caption{Graf amb un llaç (a), graf amb arestes múltiples (b) i graf dirigit (c)}
\label{fig:exemples_tipus}
\end{figure}




\emph{Nota de l'autor: a partir d'ara, i si no s'indica el contrari,
quan es parli de grafs, s'exclouran els multigrafs i grafs dirigits.}

Direm que un graf no dirigit $G=(V,E)$ és \textit{connex} si per a qualsevol $v_{i}, v_{j}\in V$ $v_{i}\neq v_{j}$ existeix un \textit{camí} (successió d'arestes) que els uneix.
\\
El nombre d'arestes que són incidents a un vèrtex $v$ (comptant els
llaços com a dues arestes) determinen el que anomenarem \textit{grau} de $v$, que es representa
amb $g(v)$. La successió de graus d'un graf serà la successió que
s'obté a l'ordenar de manera creixent els graus dels seus vèrtex. Cal
dir que no és un problema gens trivial saber si una successió de nombres naturals donada
pot ser una successió de graus d'un graf. El grau mínim d'un graf
$G=(V,E)$ queda determinat de la següent manera: $\delta(G)=min\{g(v):v\text{\ensuremath{\in}}V(G)\}$.
De manera similar, el grau màxim de $G$, $\text{\ensuremath{\Delta}}(G)=max\{g(v):v\text{\ensuremath{\in}}V(G)\}$.
\\
Si d'un graf connex en treiem una aresta o un node, en resulta un altre (o
més d'un) graf connex. Si $v\text{\ensuremath{\in}}V(G)$, indicarem per
$G-v$ al graf que s'obté al suprimir el vèrtex $v$ i totes les
seves arestes incidents. De la mateixa manera, si $e\text{\ensuremath{\in}}E(G)$,
$G-e$ indicarà el graf que s'obté a l'eliminiar la aresta $e$.

Amb tots aquests conceptes ja podem veure el teorema d'Euler, un dels
primers teoremes en teoria de grafs i un dels més importants.
\\
\\

\subparagraph{Teorema 1 (Euler)}
\label{teorema:Euler}
\begin{quotation}
En tot graf $G=(V,E)$, la suma dels graus dels vèrtex és igual al doble del
nombre d'arestes.\[ \sum_{v\in V(G)}g(v)=2|E|(G) \]
\end{quotation}
\emph{Demostració}: Només cal veure que cada aresta té dos extrems
i que suma dos en el total dels graus. La demostració formal és més
complicada, i comporta desenvolupar una inducció respecte del nombre d'arestes:

\begin{itemize}


\item Si $|E|=0$, no cal considerar el cas. Si $|E|=1$, o $|V|=2$ i cada
vèrtex té grau 1 o la aresta és un llaç i hi ha un sol vèrtex de grau
2. En qualsevol d'aquests dos casos, el teorema es verifica.
\item Ara suposem que el teorema està demostrat per a $|E|\leq k$ i que $G$ és un
graf amb $|E|=k+1$. Si $e$ és una aresta de $G$ prenem $H=G-e$.
\item Llavors tots els vèrtexs de $H$ tenen el mateix grau a $H$ que a
$G$ excepte 2 que tenen un grau menys o un que té dos graus menys
(només en el cas que $e$ sigués un llaç). En tots dos casos obtenim
que:\[ \sum_{v\in V(G)}g(v)=\sum_{v\in V(H)}g(v)+2=2(|E|-1)+2=2|E| \]D'aquesta
demostració en treiem una altra afirmació:

\end{itemize}

\begin{quotation}
\emph{En tot graf, el nombre de vèrtex amb grau imparell, és parell.}
\end{quotation}

\section{Tipus de grafs}
\label{Sec:tipus}

Fins ara hem vist els conceptes bàsics en teoria de grafs i algunes
de les propietats que compleixen tots els grafs. No obstant, existeixen
diversos tipus de grafs que tenen propietats especials. A continuació se'n presenten alguns


\subsection{Grafs complementaris} 
\label{sec:complementaris}

El graf complementari del graf $G$ és el graf $H$ amb els mateixos
vèrtexs que $G$, de manera que dos vèrtexs d'$H$ seran adjacents
si i només si a $G$ no ho són. Formalment, si $G=(V,E)$ és un graf
simple i $K=E(K_{n})$ és el conjunt d'arestes derivades de totes les possibles combinacions de
dos elements de $V$, essent $n=|V(G)|$, llavors $H=(V,K\setminus E)$\footnote{La notació $K\setminus E$ indica el conjunt dels elements de $K$ que no són a $E$}. 
Per indicar el complementari de $G$ s'escriu $\bar{G}$ o $G'$. 

\begin{propietat}
Per obtenir el graf complementari
de $G$ tan sols s'han de posar les arestes que falten per obtenir
un graf complet i treure totes les que hi eren inicialment (ja que
$|E(G)|+|E(\bar{{G}})|=|K|$). Veure figura \ref{fig:complementari}.
\end{propietat}

\begin{figure}[H]
\centering
	\subfloat{
		\begin{tikzpicture}[scale=.5]
			\grCirculant[RA=3, prefix=v,Math=true]{6}{2,3}
		\end{tikzpicture}
	}
	\subfloat{
		\begin{tikzpicture}[scale=.5]
			\grCirculant[RA=3, prefix=v,Math=true]{6}{1}
		\end{tikzpicture}
	}
\caption{Un graf $G$ i el seu complementari $\bar{G}$}
\label{fig:complementari}
\end{figure}


\subsection{Grafs regulars} 
\label{sec:regulars}

Es diu que un graf $G=(V,E)$ és \textit{regular de grau $r$} quan tots els seus vèrtexs
tenen grau $r$. Formalment, un graf és $r$-regular quan $\Delta(G)=\delta(G)=r$.
Un graf $0$-regular és un graf nul \footnote{Veure apartat \ref{sec:buits}}, un graf $1$-regular
consisteix en arestes separades entre elles i un graf $2$-regular
consisteix en un o més cicles \footnote{Veure apartat \ref{sec:cicles}} separats. A partir d'aquí, els grafs regulars més importants
tenen noms propis, com per exemple els $3$-regulars, que són els
\textit{cúbics}; els $4$-regulars, \textit{quàrtics}; els $7$-regulars, \textit{grafs de Witt
truncats dobles}; els $8$-regulars, \textit{grafs de 24 cel·les}... 

\begin{propietat}
No necessàriament existeix un únic graf $r$-regular, sinó
que sovint s'en poden fer amb diferent nombre de vèrtexs.
A l'imatge \ref{fig:complementari} es poden veure diversos exemples de grafs regulars,
alguns d'ells amb el mateix grau i diferent nombre de vèrtexs.
\end{propietat}

\begin{propietat}
Com a conseqüència del teorema \ref{teorema:Euler}, per a tots els grafs $r$-regulars amb $n$ vèrtexs es compleix que 

\[ |E|(G)=\frac{1}{2}nr \]on $|E|(G)$ és el nombre d'arestes.
\end{propietat}

%Cal afegir imatges de més grafs 3-regulars.

\begin{figure}[H]
\label{fig:regulars}
\centering
	\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum size=.5mm}, transform shape, scale=0.80]
		\node[round] (a) at (0,0){$v_{2}$};
		\node[round] (b) at (4,0){$v_{0}$};
		\node[round] (c) at (2,1.5){$v_{3}$};
		\node[round] (d) at (2,4){$v_{1}$};
		\draw (a) edge (b);
		\draw (a) edge (c);
		\draw (a) edge (d);
		\draw (b) edge (c);
		\draw (b) edge (d);
		\draw (c) edge (d);

	\end{tikzpicture}
\caption{Graf cúbic (3-regular)}
\end{figure}


\subsection{Graf nul i grafs buits}
\label{sec:buits}

Els \textit{grafs buits} són grafs sense arestes, és a dir, conjunts d'$n$ vértexs.
Són els complementaris dels grafs complets $K_{n}$ \footnote{Veure apartat \ref{sec:Complets}}, i per tant la seva nomenclatura
és $\bar{K}_{n}$ o, simplement, $N_{n}$. Estrictament s'anomena \textit{graf nul} a $N_{0}$
i buits a la resta, però com que normalment no s'utilitza $N_{0}$,
convencionalment es diuen nuls tots els elements del conjunt dels buits.

\begin{figure}[H]
\centering
	\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum 			size=.5mm}, transform shape, scale=0.80]
		\node[round] (a) at (0,0){$v_{0}$};
		\node[round] (b) at (4,0){$v_{1}$};
		\node[round] (c) at (8,0){$v_{2}$};
		\node[round] (d) at (0,2){$v_{3}$};
		\node[round] (d) at (4,2){$v_{4}$};
		\node[round] (d) at (8,2){$v_{5}$};
	\end{tikzpicture}
\caption{Graf buit $N_{6}$}
\end{figure}


\subsection{Grafs complets}
\label{sec:Complets}

Un \textit{graf complet} és un graf on cada vèrtex està unit a tots els altres
una sola vegada. Un graf complet amb $n$ nodes és un graf simple
i $(n-1)$-regular i la seva nomenclatura és $K_{n}$. 

\begin{propietat}
Els grafs complets tenen ${n\choose 2}=\frac{n(n-1)}{2}$ arestes. 
\end{propietat}

\begin{propietat}
El nombre de cicles que conté un graf complet queda determinat per la següent igualtat:

\[ C_{n} =\sum_{K=3}^{n}\frac{1}{2}{n\choose k}(k-1)! \]

On:
\begin{description}
\item[$\frac{1}{2}$] es multiplica perquè es contes dues vegades els cicles, ja que no són dirigits.
\item[$n\choose k$] és el nombre de grups de $k$ elements que es poden agafar.
\item[$(k-1)!$] és el nombre de permutacions circulars de $k$ elements.
\end{description}

\end{propietat}

\begin{figure}[H]
\centering
	\subfloat[]{	
		\begin{tikzpicture}
			\grComplete[RA=2, prefix=v, Math=true]{7}
		\end{tikzpicture}
	}
	\subfloat[]{
		\begin{tikzpicture}
			\grComplete[RA=2, prefix=v, Math=true]{5}
		\end{tikzpicture}
	}
\caption{Grafs complets $K_{7}$(a) i $K_{5}$(b)}
\end{figure}



\subsection{Cicles}
\label{sec:cicles}

Els \textit{cicles} són grafs 2-regulars amb $n$ vèrtexs i $n$ arestes, i
s'anomenen $C_{n}$.
 
\begin{propietat}
El graf lineal \footnote{Veure apartat\ref{sec:lineal}} d'un cicle és ell mateix.
\end{propietat}

\begin{figure}[H]
\centering	
	\begin{tikzpicture}
		\grCycle[RA=2, prefix=v, Math=true]{9}
	\end{tikzpicture}
\caption{Cicle $C_{9}$}
\end{figure}


\subsection{Grafs bipartits}
\label{sec:bipartits}

Els \textit{grafs bipartits} són aquells en els quals els vèrtexs es poden
separar en dos conjunts disjunts $U$ i $W$ (és a dir, que els dos
conjunts no tinguin elements comuns) de tal manera que un vèrtex d'un
conjunt no sigui mai adjacent a un altre vèrtex del mateix conjunt.
Es pot dir també que un graf és bipartit si i sols si no conté cicles de longitud
senar. 

\begin{propietat}
Tots els grafs $C_{n}$ amb $n$ parell, són també grafs bipartits.
\end{propietat}

\begin{figure}[H]
\centering	
	\begin{tikzpicture}[v/.style={circle, fill=red, text=white, thin, minimum size=.5mm}, u/.style={circle, fill=blue, text=white, thin, minimum size=.5mm}, transform shape, scale=0.80]
		\node[v] (a) at (0,0){$v_{0}$};
		\node[v] (b) at (2,0){$v_{1}$};
		\node[v] (c) at (4,0){$v_{2}$};
		\node[v] (d) at (6,0){$v_{3}$};
		\node[u] (e) at (1,2){$u_{0}$};
		\node[u] (f) at (3,2){$u_{1}$};
		\node[u] (g) at (5,2){$u_{2}$};
		\draw (a) edge (e);
		\draw (b) edge (e);
		\draw (b) edge (f);
		\draw (b) edge (g);
		\draw (c) edge (e);
		\draw (c) edge (f);
		\draw (d) edge (f);
		\draw (d) edge (g);
	\end{tikzpicture}
\caption{Graf bipartit}
\end{figure}


\subsection{Grafs bipartits complets}
\label{sec:bipartits_complets}

Els \textit{grafs bipartits complets} són grafs bipartits \footnote{Veure apartat \ref{sec:bipartits}} en els quals cada
element del conjunt $U$ està unit a tots els elements dels del conjunt
$W$. S'anomenen $K_{m,n}$, on $m=|U|$ i $n=|W|$.

\begin{propietat}
En els grafs bipartits $K_{m,n}=K_{n,m}$ , $|V|=n+m$ i $|E|=mn$.
\end{propietat}

\begin{figure}[H]
\centering	
	\begin{tikzpicture}[v/.style={circle, fill=red, text=white, thin, minimum size=.5mm}, u/.style={circle, fill=blue, text=white, thin, minimum size=.5mm}, transform shape, scale=0.80]
		\node[v] (a) at (0,0){$v_{0}$};
		\node[v] (b) at (2,0){$v_{1}$};
		\node[v] (c) at (4,0){$v_{2}$};
		\node[v] (d) at (6,0){$v_{3}$};
		\node[v] (h) at (8,0){$v_{4}$};
		\node[u] (e) at (1,2){$u_{0}$};
		\node[u] (f) at (3,2){$u_{1}$};
		\node[u] (g) at (5,2){$u_{2}$};
		\node[u] (i) at (7,2){$u_{3}$};
		\draw (a) edge (e);
		\draw (a) edge (f);
		\draw (a) edge (g);
		\draw (a) edge (i);
		\draw (b) edge (e);
		\draw (b) edge (f);
		\draw (b) edge (g);
		\draw (b) edge (i);
		\draw (c) edge (e);
		\draw (c) edge (f);
		\draw (c) edge (g);
		\draw (c) edge (i);
		\draw (d) edge (e);
		\draw (d) edge (f);
		\draw (d) edge (g);
		\draw (d) edge (i);
		\draw (h) edge (e);
		\draw (h) edge (f);
		\draw (h) edge (g);
		\draw (h) edge (i);
	\end{tikzpicture}
\caption{Graf bipartit complet $K_{4,5}$}
\end{figure}


\subsection{Grafs estrella}	
\label{sec:estrella}

Un \textit{graf estrella} de grau $n$ és aquell que conté un vèrtex amb grau $n-1$ i els
$n-1$ vèrtexs restants de grau 1.
La seva nomenclatura és $S_{n}$. 

\begin{propietat}
Són estrelles tots els grafs bipartits de la forma $K_{1,n-1}$ o $K_{n-1,1}$. 
\end{propietat}
\begin{propietat}
El graf lineal de $S_{n}$ és $K_{n-1}$.
\end{propietat}

\begin{figure}[H]
\centering
	\begin{tikzpicture}
		\grStar[RA=2, prefix=v, Math=true]{7}
	\end{tikzpicture}
\caption{Graf estrella $S_{7}$}
\end{figure}


\subsection{Graf lineal}
\label{sec:lineal}
Un graf lineal $L(G)$ d'un graf $G$ és un graf que representa les
adjacències entre les arestes de $G$. Formalment, donat un graf $G$,
el graf lineal $L(G)$ és aquell en el qual cada vèrtex correspon
a una aresta de $G$ i dos vèrtexs són adjacents només si les arestes
corresponents a $G$ comparteixen un vèrtex.

\begin{propietat}
El graf lineal d'un graf amb $n$ nodes, $e$ arestes i amb vèrtexs de graus
$g(v_{i})$ té $n'=e$ nodes i \[ e'=\frac{1}{2} \sum_{i=1}^{n}g(v_{i})^{2}-e \]arestes.
\\
\emph{Demostració}: Cada node $v_{i}$ amb grau $g(v_{i})$ del graf original generarà un graf complet de $g(v_{i})$ nodes ($K_{g(v_{i})}$).

	\begin{figure}[H]
		\centering
		\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum size=.5mm}, invisible/.style={shape=coordinate}, transform shape, scale=0.5]
			\node (a)[invisible] at (0,0){};
			\node (k)[invisible] at (14,0){};

			\node (g)[invisible] at (0,0.5){};
			\node (h)[invisible] at (3.5,0.5){};
			\node (i)[invisible] at (6.75,0.5){};
			\node (j)[invisible] at (14,0.5){};
			
			\node (b)[round] at (0, 6){$v_{i}$};

			\node (c) at (0,3){$w_{i_{0}}$};
			\node (d) at (2.5,2){$w_{i_{1}}$};
			\node (e) at (5,2){$w_{i_{2}}$};
			\node (f) at (7.5,3){$w_{i_{g(v_{i})}}$};
			
			\draw (b) edge (c);
			\draw (b) edge (d);
			\draw (b) edge (e);
			\draw (b) edge (f);
			\draw (c) edge (g);
			\draw (d) edge (h);
			\draw (e) edge (i);
			\draw (f) edge (j);
						
			\draw (c) edge[dashed] (d);
			\draw (c) edge[dashed] (e);
			\draw (c) edge[dashed] (f);
			\draw (d) edge[dashed] (e);
			\draw (d) edge[dashed] (f);
			\draw (e) edge[dashed] (f);
			
			\tikzset{doble/.style={<->,dashed}}
			\draw (a) edge[doble] node[midway,below]{$g(v_{i})$}(k);
						
		\end{tikzpicture}
	\end{figure}


Tal com s'ha vist a l'apartat \ref{sec:Complets}, un graf complet té ${n\choose k} = \frac{n(n-1)}{2}$, per tant en aquest cas se'n generen $\frac{g(v_{i})(g(v_{i})-1)}{2}$. Però això es compleix per a cada vèrtex, i llavors podem escriure \[ \sum_{i=1}^{n}\frac{1}{2}g(v_{i})(g(v_{i})-1) = \frac{1}{2}\sum_{i=1}^{n}(g(v_{i})^{2}-g(v_{i})) = \frac{1}{2}\sum_{i=1}^{n}g(v_{i})^{2} - \underbracket{\frac{1}{2}\underbracket{\sum_{i=0}^{n}g(v_{i})}_{2|E|}}_{|E|} = \frac{1}{2}\sum_{i=1}^{n}g(v_{i})^{2}-e\]
\end{propietat}
\begin{figure}[H]
\centering
	\subfloat[$G$]{
		\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum size=.5mm}, transform shape, scale=0.5]
			\node[round] (a) at (8,4){$v_{0}$};
			\node[round] (b) at (4,8){$v_{1}$};
			\node[round] (c) at (0,8){$v_{2}$};
			\node[round] (d) at (0,4){$v_{3}$};
			\node[round] (e) at (4,0){$v_{4}$};
			\draw (a) edge (b);
			\draw (a) edge (d);
			\draw (a) edge (e);
			\draw (b) edge (c);
			\draw (b) edge (d);
			\draw (d) edge (e);
		\end{tikzpicture}
	}
	\subfloat[$G+L(G)$]{
		\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum size=.5mm}, transform shape, scale=0.5]
			\node[round] (a) at (8,4){$v_{0}$};
			\node[round] (b) at (4,8){$v_{1}$};
			\node[round] (c) at (0,8){$v_{2}$};
			\node[round] (d) at (0,4){$v_{3}$};
			\node[round] (e) at (4,0){$v_{4}$};
			\node[draw, diamond] (f) at (6,6){$u_{0}$};
			\node[draw, diamond] (g) at (2,8){$u_{1}$};
			\node[draw, diamond] (h) at (2,6){$u_{2}$};
			\node[draw, diamond] (i) at (2,2){$u_{3}$};
			\node[draw, diamond] (j) at (6,2){$u_{4}$};
			\node[draw, diamond] (k) at (4,4){$u_{5}$};
			\draw (a) edge (f);
			\draw (a) edge (j);
			\draw (a) edge (k);
			\draw (f) edge (b);
			\draw (j) edge (e);
			\draw (k) edge (d);
			\draw (b) edge (g);
			\draw (g) edge (c);
			\draw (b) edge (h);
			\draw (h) edge (d);
			\draw (d) edge (i);
			\draw (i) edge (e);
			
			\draw (f) edge[dashed] (h);
			\draw (k) edge[dashed] (f);
			\draw (k) edge[dashed] (j);
			\draw (k) edge[dashed] (i);
			\draw (k) edge[dashed] (h);
			\draw (f) edge[dashed] (h);
			\draw (i) edge[dashed] (j);
			\draw (g) edge[dashed] (h);
			\draw (f) edge[dashed] (j);
			\draw (h) edge[dashed] (i);
			\draw (g) edge[dashed, bend left=75] (f);
			
		\end{tikzpicture}
	}
	\subfloat[$L(G)$]{
		\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum size=.5mm}, transform shape, scale=0.5]
			\node[draw, diamond] (f) at (6,6){$u_{0}$};
			\node[draw, diamond] (g) at (2,8){$u_{1}$};
			\node[draw, diamond] (h) at (2,6){$u_{2}$};
			\node[draw, diamond] (i) at (2,2){$u_{3}$};
			\node[draw, diamond] (j) at (6,2){$u_{4}$};
			\node[draw, diamond] (k) at (4,4){$u_{5}$};
			\draw (f) edge (h);
			\draw (k) edge (f);
			\draw (k) edge (j);
			\draw (k) edge (i);
			\draw (k) edge (h);
			\draw (f) edge (h);
			\draw (i) edge (j);
			\draw (g) edge (h);
			\draw (f) edge (j);
			\draw (h) edge (i);
			\draw (g) edge (f);
		\end{tikzpicture}
	}
\caption{Procés de construcció d'un graf lineal}
\end{figure}

\subsection{Rodes}
\label{sec:rodes}

Un \textit{graf roda} amb $n$ vèrtex ès un graf que conté un cicle de longitud $n-1$, on tots els vèrtex del cicle estan connectats a un vèrtex fora del cicle, anomenat node central. S'escriu $W_{n}$, i a vegades simplement s'estudia com a $C_{n-1}+K_{1}$. 

\begin{propietat}
El node central té grau $n-1$, i la resta de nodes tenen grau $3$.
\end{propietat}
\begin{propietat}
El nombre de cicles que conté un graf roda amb $n$ vètrexs està determinat per $n^{2}-3n+3$.
\\
\emph{Demostració}: El nombre de cicles que conté un graf roda és la suma del nombre de cicles de longitud des de 3 fins a $n$ ($\sum_{i=3}^{n}C_{i}$). Amb l'exepció de $C_{n-1}$, el nombre de cicles per a cada $i$ és $n-1$. En el cas de $C_{n-1}$ n'hi ha $n$ de possibles, però ho representem de la manera $n-1+1$, per tal que sigui més còmode operar. Com que els cicles són possibles a partir de longitud 3, en total hi ha $n-2$ longituds possibles. D'aquesta manera podem escriure $(n-2)(n-1)+1=\boxed{n^{2}-3n+3}$.  
\end{propietat}


\begin{figure}[H]
\centering
	\begin{tikzpicture}
		\grWheel[RA=2, prefix=v, Math=true]{10}
	\end{tikzpicture}
\caption{Roda $W_{10}$}
\end{figure}

\subsection{Xarxes}
\label{sec:xarxes}

Els \textit{grafs xarxes} bidimensionsals $G_{m,n}$ són grafs bipartits que formen un entramaten forma de cuadrícula de $mn$ vèrtexs. 
\begin{propietat}
Es pot greneralitzar per a xarxes de més dimensions com a $G_{m,n,o,...}$. 
\end{propietat}
\begin{propietat}
Un graf xarxa té $mn$ vèrtexs i $(m-1)n+(n-1)m$ arestes. 

\emph{Demostració}: Tal com es pot veure a la figura \ref{fig:graus_xarxes}, un graf xarxa té 
\[
(n-2)(m-2)+2(m-2)+2(n-2)+4 = nm -\cancel{2m}-\cancel{2n}+\cancel{4}+\cancel{2m}-\cancel{4}+\cancel{2n}-\cancel{4}+\cancel{4} = mn
\] vèrtexs. D'altra banda, la suma dels graus de tots els vèrtexs és
\[
\frac{4(m-2)(n-2)+3\times 2(m-2+n-2)+4\times 2}{2} = 2(m-2)(n-2)+3(m-2)+3(n-2)+4
\]
Si es desenvolpua, s'obté
\[
(n-2)(m-2) + \important{(n-2)(m-2)+2(m-2)}+(m-2)+\important{2(n-2)}+(n-2)+\important{4}
\]
on la suma dels elements marcats equival a $mn$. Si es continua desenvolupant tinguent en compte aquest detall, s'obté
\[
mn-2m-2n+4+m-2+n-2+mn = 2mn-m-n=\boxed{m(n-1)+n(m-1)}
\]

	\begin{figure}[H]
	\label{fig:graus_xarxes}
	\centering
		\begin{tikzpicture}[round/.style={circle, draw=black, fill=black, thin, minimum size=1mm}, invisible/.style={shape=coordinate}, central/.style={circle, draw=white, fill=white, thin, minimum size=1mm}, transform shape]
			\node (a)[round,label=grau 2] at (0,0){};
			\node (b)[round,label=grau 2] at (12,0){};
			\node (c)[round,label=grau 2] at (0,8){};
			\node (d)[round,label=grau 2] at (12,8){};
			\node (e)[invisible] at (1,0){};
			\node (f)[invisible] at (11,0){};
			\node (g)[invisible] at (0,1){};
			\node (h)[invisible] at (12,1){};
			\node (i)[invisible] at (0,7){};
			\node (j)[invisible] at (1,8){};
			\node (k)[invisible] at (11,8){};
			\node (l)[invisible] at (12,7){};
			\node (m)[invisible] at (1,1){};
			\node (n)[invisible] at (1,7){};
			\node (o)[invisible] at (11,1){};
			\node (p)[invisible] at (11,7){};
			\node (q)[central] at (6,4){grau 4};
			
			\draw (m) edge node [midway, fill=white]{\scriptsize{$n-2$}}(n);
			\draw (n) edge node [midway, fill=white]{\scriptsize{$m-2$}}(p);
			\draw (p) edge (o);
			\draw (o) edge (m);
			
			\draw (j) edge node [midway, fill=white, label={[yshift=0.01cm]\scriptsize{grau 3}}]{\scriptsize{$m-2$}}(k);
			\draw (e) edge node [midway, fill=white, label={[yshift=0.01cm]\scriptsize{grau 3}}]{\scriptsize{$m-2$}}(f);
			\draw (g) edge node [midway, fill=white, label={[xshift=-1cm, yshift=0cm]\scriptsize{grau 3}}]{\scriptsize{$n-2$}}(i);
			\draw (h) edge node [midway, fill=white, label={[xshift=1cm, yshift=0cm]\scriptsize{grau 3}}]{\scriptsize{$n-2$}}(l);
		
			

		\end{tikzpicture}
		\caption{Representació dels graus dels diferents nodes d'un grau xarxa}
	\end{figure}



\end{propietat}


\begin{figure}[H]
\centering
	\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum 			size=.5mm}, transform shape, scale=0.80]
		\node[round] (a) at (0,0){$v_{0}$};
		\node[round] (b) at (4,0){$v_{1}$};
		\node[round] (c) at (8,0){$v_{2}$};
		\node[round] (d) at (0,2){$v_{3}$};
		\node[round] (e) at (4,2){$v_{4}$};
		\node[round] (f) at (8,2){$v_{5}$};
		\node[round] (g) at (0,4){$v_{6}$};
		\node[round] (h) at (4,4){$v_{7}$};
		\node[round] (i) at (8,4){$v_{8}$};
		\draw (a) edge (b);
		\draw (a) edge (d);
		\draw (b) edge (c);
		\draw (b) edge (e);
		\draw (c) edge (f);
		\draw (d) edge (e);
		\draw (d) edge (g);
		\draw (e) edge (h);
		\draw (e) edge (f);
		\draw (f) edge (i);
		\draw (h) edge (i);
		\draw (h) edge (g);
	\end{tikzpicture}
\caption{Graf xarxa $G_{3,3}$}
\end{figure}


\subsection{Arbres}
\label{sec:arbres}

Els \textit{arbres} són un tipus molt important de grafs: són grafs connexos
sense cicles, de manera que existeix un únic camí entre dos vèrtexs.
\begin{propietat}
Si a un arbre se li afegeix una aresta, es genera un cicle, i se s'en
treu una, el graf deixa de ser connex.
\end{propietat} 
\begin{propietat}
Hi ha un tipus especial d'arbres anomenats \textit{elementals o camins}, que són els arbres amb $|V|=1$, $|V|=2$ i en general tots aquells on $\delta=1$ i $\Delta=2$. S'anomenen $P_{n}$, on $n=|V|$.
També es pot pensar en grafs elementals com a $G_{n,1}$.
\end{propietat}


\begin{figure}[H]
\centering
	\subfloat[]{
		\begin{tikzpicture}[round/.style={circle, draw=black, thin, minimum 			size=.5mm}, transform shape, scale=0.80]
			\tikzstyle{level 1}=[level distance=15mm,sibling distance=35mm]
			\node(0)[round]{$v_{0}$}
				child{node[round]{$v_{1}$}
					child{node[round]{$v_{3}$}}}
				child{node[round]{$v_{2}$}
					child{node[round]{$v_{4}$}}
					child{node[round]{$v_{5}$}}
			};
		\end{tikzpicture}
	}
	\subfloat[]{
		\begin{tikzpicture}
			\grEmptyPath[RA=1, prefix=v, Math=true]{4}
			\EdgeInGraphLoop*{v}{4}
		\end{tikzpicture}	
	}
\caption{Arbre (a) i graf elemental $P_{4}$ (b)}
\end{figure} 


\subsubsection*{Teorema 2}
\begin{quote}
Un arbre amb $n$ nodes té $n-1$ arestes. 
\end{quote}
\emph{Demostració: }Si comprovem el cas on un arbre $T$ té $n=1$ vèrtexs, veiem que no té cap aresta, per tant el teorema es compleix. Si treiem una aresta de l'arbre,en sorgiran 2 arbres més $T_{1}$ i $T_{2}$. Per hipòtesi, $T_{1}$ tindrà $v_{1}=|V|(T_{1})$ vèrtexs i $n_{1}-1=|E(T_{1})|$ arestes, i $T_{2}$ tindrà $n_{2}=|V(T_{2})|$ vèrtexs i $n_{2}-1=|E|(T_{2})$ arestes.  Llavors el nombre d'arestes de $T$ és $(n_{1}-1)+(n_{2}-1)+1 = (n_{1}+n_{2})-1$. Deduïm llavors que el nombre de nodes de $T$ és $n_{1}+n_{2}$. Dit d'una altra manera, $|E(T)|=|V(T)|-1$.

Com a conseqüència d'aquest teorema, en podem arribar a un altre:

\subsubsection*{Teorema 3}
\begin{quote}
En un arbre $T$ amb $|V|\geq 2$, hi ha com a mínim dos vèrtexs de grau 1 (anomenats fulles).
\end{quote}
\emph{Demostració: } Com a conseqüència del Teorema 1 i Teorema 2 podem dir que en un arbre \[\sum_{v\in V}g(v)=2|E|=2|V|-2\] També podem deduïr que si tots els vèrtexs tinguessin un grau $g(v_{i}) > 1$, llavors \[ \sum_{v\in V}g(v) \geq \sum_{v\in V}2 =2|V|\] Sabem que això no és correcte, ja que estem dient que $2|V|-2\geq2|V|$. Amb això ja podem veure que necessitem treure com a mínim dos graus, però demostrem també que amb un sol node de grau 1 tampoc és suficient. \smallskip Suposem ara que l'arbre té un sol node tal que $g(v)=1$ i elsaltres tenencom a mínim grau 2. Llavors \[ 2|V|-2=\sum_{v\in V}g(v)=1+\sum_{\substack{v\in V\\\text{si }g(v)\neq 1}}g(v)\geq 1+\sum_{\substack{v\in V \\\text{si }g(v)\neq 1}}2=1+2(|V|-1)=2|V|-1 \] Ara estem dient que $2|V|-2 \geq 2|V|-1$, que torna a ser una contradicció. Sabem que si treiem un grau més, el teorema es complirà, i hem demostrat que el mínim nombre de vèrtexs de grau 1 és 2.

Hi ha un altre teorema que relaciona el nombre de fulles amb el grau màxim d'un arbre:

\subsubsection*{Teorema 4}
\begin{quote}
El nombre de fulles d'un arbre $T$ és més gran o igual a $\Delta$.
\end{quote}
\emph{Demostració: }Si eliminem el node de grau $\Delta$ de l'arbre, juntament amb totes les seves arestes incidents, obtenim un conjunt de $\Delta$ grafs. Si alguns d'aquests grafs consisteixen en tan sols un node, vol dir que abans eren adjacents al node que hem eliminat, per tant, només tenien grau 1. Si, pel contrari, formen nous arbres, pel teorema 3 podem dir que hi haurà com a mínim dues fulles. Encara que hi ha la possibilitat que un dels nodes amb grau 1 sigués l'adjacent a el node que hem tret, sempre podem garantir que hi ha com a mínim una fulla. Per tant, també podem garantir que que hi haurà com a mínim $\Delta$ fulles.

\part{Camins i algorismes}

Sovint, quan utilitzem un graf per modelitzar quelcom, ens interessa
poder-hi fer algunes operacions. Podem, per exemple, voler trobar
un camí entre dos punts, recòrrer el graf sencer o trobar el camí
més curt per anar d'un vèrtex a un altre. Per aquest motiu utilitzem
els camins, que trobarem o generarem mitjnçant diversos algorismes.

En aquesta secció mostraré diverses maneres de recòrrer un graf, torbant
la manera més eficient per a cada cas.

\subsection{Grafs ponderats i dirigits}
\subsubsection*{Grafs ponderats}
Els grafs ponderats són grafs on cada aresta $e$ està asociada a un nombre $w(e)$ anomenat pes o cost, tal que $w(e)\in \mathbb{R}$. El pes pot representar diverses quantitats, segons el que es vulgui modelitzar. 
Moltes vegades s'utilitza per representar distàncies, però si per exemple modelitzem una xarxa de distribució d'aigua, ens pot interessar representar el cabal de les canonades, o en una xarxa de bus, la densitat de trànsit de cada tram. 

\subsubsection*{Grafs dirigits}
Els grafs dirigits són grafs les arestes dels quals només admeten una direcció. D'aquesta manera, una aresta $e_{0}=(v_{0},v_{1}) \neq e_{1}=(v_{1},v_{0})$. De fet, no necessàriament ha d'existir una aresta contrària a una altra. 

Aquest tipus de grafs poden ser útils per representar carreteres, o moviments vàlids en algun joc. 


\subsection{Camins}

Un \textit{camí} $p$ és una seqüència finita i ordenada d'arestes que connecta
una seqüència ordenada de vèrtexs. Un camí $p$ de longitud $k$ (expressat com a $l(p)=k$) entre el vèrtex inicial $v_{0}$ i el vèrtex final $v_{k}$ sempre que $v_{0}\neq v_{k}$) és una successió de $k$ arestes i $k+1$ vèrtexs de la forma $\overline{v_{0},v_{1}}, \overline{v_{1},v_{2}},\cdots, \overline{v_{k-1},v_{k}}$  . Per definició, també es pot representar un camí $p$ entre $v_{0}$ i $v_{k}$ com a successió de vèrtex $p=v_{0}v_{1}\cdots v_{k}$. En aquest cas, pot ser tractat com un graf elemental $P_{n}$. 

Un cas especial és quan el camí comença i acaba al mateix vèrtex ($v_{0} = v_{k}$). Llavors el camí és un cicle, i és l'equivalent a un graf cicle $C_{n}$. 

Quan un camí té totes les arestes diferents, s'anomena \textit{simple}, i si a més té tots els vèrtexs diferents, s'anomena \textit{elemental}.

En els grafs, ponderats, la \textit{longitud} d'un camí $c=v_{0},v_{1},\cdots,v_{n}$ no es defineix pel nombre d'arestes per on passa el camí, sinó fent el sumatori dels pesos de les arestes
\[ \textbf{longitud}_{w}(c)=\sum_{i=0}^{n-1}w(\overline{v_{i},v_{i+1}}) \]

La \textit{distància} entre dos vèrtexs $v$ i $u$, $d_{w}(v,u)$, és la que s'obté al agafar la menor longitud d'entre tots els camins elementals entre $v$ i $u$. 
(adjunjtar exemple de distància)


\section{Estructures de dades dels grafs}

En els grafs, normalement s'ha de tractar una gran quantitat d'informació:
nodes, arestes, pesos, sentits... Tota aquesta informació no és difícil
de gestionar si el graf que s'estudia és petit, ja que fins i tot
es pot dibuixar. El problema sorgeix quan el graf en qüestió és més
gran, com per exemple podria ser una xarxa de clavagueram o de metro.
Llavors la informació a tractar és molta, i és convenient organitzar-la
en estructures de dades. Les estructures de dades solen ser utilitzades
en la programació, però en aquest cas sol ser beneficiós tenir-ne
fins i tot quan no es treballa amb informàtica.


\subsection*{Matrius}


\subsubsection*{Matriu d'adjacència}

La matriu d'adjacència d'un graf és una matriu quadrada que conté
informació respecte el nombre d'arestes que uneixen dos nodes, i s'organitza
de la següent manera:

Si $G$ és un graf amb $n$ nodes, $A(G)=(a_{i,j})_{i,j}=1,...,n$
és la seva matriu d'adjacència de $n$ x $n$, on $a_{i,j}$ correspon
al nombre d'arestes que uneixen els nodes $i,j$, contant com a 2
els llaços, que sempre es trobaràn a la diagonal. La matriu serà simètrica
si el graf ho ès, i podrem conèixer el grau d'un node $i$ fent el sumatori de les caselles de la $i$-èsima fila. A vegades, quan s'utilitzen grafs ponderats, les matrius d'adjacència s'omplen amb els pesos de les arestes, per no haver d'utilitzar altres estructures per emmagatzemar la resta d'informació. En aquest tipus de grafs, els llaços no necessàriament valdràn 2, però es podràn diferenciar perquè estaràn a la diagonal. En aquest cas, el problema serà que no es podràn representar arestes múltiples amb pesos diferents. Tot i això, en termes de programació, utilitzar aquesta estructura de dades (sobretot en grafs grans) no
és el més eficient, ja que creix molt ràpidament. La matriu d'un graf
de $n$ nodes té $n^{2}$ espais, i en grafs poc densos, la majoria
d'espais estan ocupats per $0$, de tal manera que s'està utilitzant
molta memòria que no conté informació útil. De la mateixa manera,
si afegim un nou node al graf, que serà l'$n$-èssim, s'hauràn d'afegir
$2n-1$ espais a la matriu.




\subsubsection*{Matriu d'incidència}

La matriu d'incidència d'un graf $G$ sense llaços, $I(G)=(b_{i,j})_{i=1,...,|V|(G),j=1,...,|E|(G)}$, és la matriu binaria de $|V|(G)\times |E|(G)$ on $b_{i,j}$
indica si la aresta $j$ és incident al node $i$.


%\begin{figure}[H]
%\label{fig:exemple matrius}
%		\begin{tikzpicture}[round/.style={circle, text=white, thin, minimum size=.5mm}, transform %shape, scale=0.80]
%			\node[round] (a) at (4,0){$v_{0}$};
%			\node[round] (b) at (2,4){$v_{1}$};
%			\node[round] (c) at (0,0){$v_{2}$};
%			\node[round] (d) at (2,0){$v_{3}$}
%			\node[round] (e) at (2,1.5){$v_{4}$};
%			\draw (a) edge (b);
%			\draw (a) edge (d);
%			\draw (b) edge (c);
%			\draw (b) edge (e);
%			\draw (c) edge (d);
%			\draw (d) edge (e);
%		
%		\end{tikzpicture}
%
%\caption{Graf (a) amb la seva matriu d'adjacència (b) i d'incidència (c)}
%\end{figure}


\subsection*{Llistes d'adjacència}

Aquesta estructura de dades és molt utilitzada per tractar grafs,
ja que ocupa menys memòria i només inclou l'informació necessària.
Les llistes d'adjacència consisteixen en un conjunt de $n$ llistes.
Cada llista correspon a un node del graf, i conté els nodes al quals
és adjacent. En informàtica s'acostumen a fer mitjançant apuntadors,
de tal manera que, a partir de cada element de la llista, es pugui
accedir a la seva pròpia llista, siguent així molt més senzill fer
iteracions. Amb l'esquema següent es pot veure més clarament:

(afegir esquema de les llistes d'adjacència)



\subsection{Algorismes}
Un algorisme és un conjunt d'instruccions precises i ben definides que, donada una entrada, calculen la sortida corresponent segons les instruccions que té.
A continuació s'en mostren uns quants d'importants.

\subsubsection{BFS}
Aquest algorisme serveix per examinar l'estructura d'un graf o fer-ne un recorregut sistemàtic. La recerca per amplada prioritàtia (\emph{breadht-first serch} en anglès, d'aquí \textbf{BFS}) fa l'exploració en paral·lel de de totes les alternatives posibles per nivells des del vèrtex inicial. A la següent imatge es pot veure com funcionaria aquest algorisme en un graf:
(Adjuntar imatge de BFS)
 
Per programar aquest algorisme s'acotuma a utilitzar un contenidor de tipus cua, que només permet afegir elements al final de la cua i treure'n de l'inici, sense poder accedir a elements del mig de la cua.
El que farà això és bàsicament imprimir per pantalla la seqüència de vèrtexs ordenada segons l'ordre en que els ha visitat.    

\begin{algorisme}
\DontPrintSemicolon
\KwData{Un graf $G$ i un node inicial $v$}
\KwResult{Seqüència de de nodes visitats}
nova cua Q\;
marca $v$ com a visitat\;
imprimeix($v$)\;
afegeix $v$ a la cua $Q$\;
nou node $auxiliar$\;
nou node $seg\ddot{u}ent$\;
\While{la cua no estigui buida}
{
	$auxiliar$ = primer element de $Q$\;
	imprimeix($auxiliar$)\;
	elimina(primer element de $Q$)\;
	
	\While{hi hagi nodes adjacents a $auxiliar$ i aquests no s'hagin visitat}
	 {
	 	marca adjacent($auxiliar$) com a visitat\;
	 	afegeix adjacent($auxiliar$) a la cua\; 
	 }
	   
}
\ForEach{node de $G$}{marca'l com a no visitat}
\caption{BFS}

\end{algorisme}
Aquesta és una manera bastant usual de programar el BFS, i encara que ès eficient, s'està desaprofitant propietats de l'algorime. Amb BFS es pot saber a quina distància del punt inicial està cada node, el camí més curt per anar del node inicial a qualsevol altre i fins i tot es pot generar un arbre expansiu mínim, agafant les arestes per on passa el BFS.
El següent algorisme té en compte aquests detalls. Està pensat per ser implementat en el llengüatge Python, i per aquest motiu utilitza diccionaris (llistes on cada element té un nom i una clau), però en llenguatges basats en C, es poden utilitzar maps de la mateixa manera.

\begin{algorisme}
\DontPrintSemicolon
\KwData{Un graf $G$ i un node inicial $v$}
\KwResult{Seqüència de nodes visitats, distància de cada node resperce $v$}
nou diccionari $dist$\;
$dist[v]=0$\;
nou diccionari $anterior$\;
$anterior[v]=Nul$\;
$i=0$\;
nova llista $frontera$
afegeix $v$ a $frontera$\;
imprimeix($v$)\;
\While{frontera no estigui buida}
{
	nova llista $seg\ddot{u}ent$\;
	\ForEach{node $x$ de $frontera$} 
	{
		\tcc{A cada iteració, $x$ agafarà un valor diferent de $frontera$} 
		\ForEach{node $y$ adjacent a $x$ }
		{
			\If{$y$ no existeix dins $dist$}
			{
				$dist[y]=i$\;
				$anterior[y]=x$\;
				afegeix $y$ a $seg\ddot{u}ent$\;
				imprimeix($y$)\;			
			}		
		}
	}
	$frontera=seg\ddot{u}ent$\;
	$i=i+1$\;
}
imprimeix($dist$)\;
\end{algorisme}

Encara que aquest algorisme sembli molt senzill, ens pot aportar informació important, i fins i tot permet resoldre problemes senzills on haguem de trobar distàncies o el camí més curt entre dos nodes.
Aquest algorisme s'utilitza també per operacions més complexes, com les següents: 
\begin{itemize}

\item Google l'utilitza per indexar pàgines web noves al seu buscador. Amb BFS pot recòrrer tota la xarxa d'internet sencera, i ,si cada pàgina web és un node i cada enllaç és una aresta, si es posa un link d'una pàgina no indexada a una que sí ho està, l'algorisme trobarà el nou node).
\item Les xarxes socials l'utilitzen per suggerir amistats. Amb BFS poden trobar els amics d'una persona (els nodes que estàn a distància 2 d'aquesta), que són susceptibles a ser amics seus. Com més amistats en comú amb la persona a distància 2, més probable és que es coneguin. 
\item Es pot sil·lucionar un cub de rubik amb aquest algorisme. Si s'aconsegueix generar un graf on cada node sigui un estat diferent del cub i les arestes siguin un moviment d'una cara, donat un estat inicial, amb BFS arribes a l'estat resolt amb els mínims moviments possibles.

\end{itemize}
 

\subsubsection{DFS}
La recerca per profunditat prioritària (\emph{depth-first search} en anglès, d'aquí \textbf{DFS}) és un algorime que utilitza uns proncipis semblants al BFS, però en lloc de cobrir tota l'amplada d'un nivell abans de passar al següent, el que fa és cobrir tota la prfunditat possible (arribar el més lluny possible) abans de tornar enrere. En la següent imatge es pot veure un esquema del funcionament de l'algorisme:
(adjuntar imatge de DFS)
Tal com en el BFS, també hi ha diverses maneres de fer l'algorisme, i en presentaré dues. La primera utilitza un contenidor de tipus pila, on només es pot manipular, afegi o treure l'element de dalt de tot de la pila.

\begin{algorisme}
\DontPrintSemicolon
\KwData{Un graf $G$ i un node inicial $v$}
\KwResult{Seqüència de nodes visitats}
nova pila $S$\;
nou node $seg\ddot{u}ent$\;
marca $v$ com a visitat\;
imprimeix($v$)\;
afegeix $v$ a la pila $S$\;
\While{la pila no estigui buida}
{	
	$seg\ddot{u}ent=$ node adjacent no visitat de l'element superior de $S$\;
	\tcc{En cas que no n'hi hagi cap, $seg\ddot{u}ent=Nul$} 
	\uIf{$seg\ddot{u}ent=Nul$}
	{
		elimina(element superior de $S$)\;	
	}
	\Else
	{
		marca $seg\ddot{u}ent$ com a visitat\;
		imprimeix($seg\ddot{u}ent$)\;
		afegeix $seg\ddot{u}ent$ a $S$\; 
	}
}



\caption{DFS}
\end{algorisme}

Aquest métode, però, té un problema, i és que només funciona per a grafs no dirigits. Hi ha la possibilitat que, treballant amb un graf dirigit, un node del graf no sigui accessible des del node inicial que hem determinat. Aquest cas excepcional es pot arreglar fent que cada node no visitat per les iteracions anteriors sigui l'inicial. El segon algorisme, a part d'arreglar això, utilitza una funció recursiva (una funció que es crida a si mateixa).



\begin{algorithm}[H]
\KwData{Un graf $G$}
\KwResult{Seqüència de nodes visitats des de cada node}
\DontPrintSemicolon
nou diccionari $anterior$\;
nova llista $ordre$\;
\ForEach{node $u$ del graf}
{
	\If{$u$ no existeix dins $anterior$}
	{
		imprimeix($u$)\;
		$anterior[u]=Nul$\;
		DFSrecursiu($G, u$)\;
	}

}
inverteix $ordre$\;
imprimeix($ordre$)\;

\;
\tcc{La funció DFSrecursiu queda determinada pel següent algorisme:} 
\SetKwFunction{Fdfs}{DFSrecursiu}
\SetKwFunction{FMain}{Programa principal}
\SetKwProg{Fn}{Funció}{}{}
\Fn{\Fdfs{$G$, $v$}}
{
	\ForEach{node $x$ adjacent a $v$}
	{
		\If{$x$ no existeix a $anterior$}
		{
			imprimeix($x$)\;
			$anterior[x]=Nul$\;
			DFSrecursiu($G, x$)\;
		}
	}
	\tcc{Només si es vol obtenir la seqüència de recursió o ordenació topològica per a grafs dirigits acíclics,}  
	afegeix $v$ a $ordre$\;	     
}

  

\end{algorithm}

Aquest algorisme no té tantes utilitats pràctiques com el BFS, però també té propuietats utils, com per exemple, que passa per totes les arestes.A través d'ell podem obtenir informació importanat d'un graf:
\begin{itemize}
\item Es pot saber si un graf té cicles, comprovant si quan estem a l'iteració d'un node (encara no n'hem explorat tots els nodes adjacents) el trobem a ell mateix. En cas afirmatiu voldrà dir que hi ha un cicle.
\item Es pot saber si un graf és bipartit assignant un color (entre un total de 2 colors possibles) a cada node mentre es recorre el graf, de manera que un node tingui un color diferent al dels nodes adjacents. Si això és possible voldrà dir que el graf és bipartit.
\item Es pot dur a terme una ordenació topològica, si es tracta d'un graf dirigit sence cicles. Un exemple d'ordenció topològica és quan hi ha una llista de tasques a fer però per fer-ne una determinada, cal haver-ne fet primer una altra. Amb el DFS, podem obtenir una de les seqüències vàlides per completar totes les tasques. A continuació es presenta un exemple d'ordenació topològica utilitzat dirant la creació d'aquest treball:

Resulta que, a la secció \ref{Sec:tipus}, quan explicava un tipus concret de graf, sovint utilitzava altres tipus de graf. Per determinar en quin ordre havien d'estar els apartats, de tal manera que quan apareixès un tipus de graf (a una altra definició) aquest ja s'hagués explicat, es va utilitzar una ordenació topològica. Es va construïr un graf dirigit representant les dependències de cada apartat (veure figura \ref{fig:topological_sort}), i es va executar l'algorisme d'ordenació topològica.
\end{itemize}

\begin{figure}[H]
\centering
\label{fig:topological_sort}
	\begin{tikzpicture}
		\node (a) at (0,0){xarxes};
		\node (b) at (3,0){arbres};
		\node (c) at (6,0){rodes};
		\node (d) at (9,0){buits};
		\node (e) at (0,2){bipartits complets};
		\node (f) at (3,2){bipartits};
		\node (g) at (6,2){cicles};
		\node (h) at (9,2){complets};
		\node (i) at (0,4){regulars};
		\node (j) at (3,4){lineals};
		\node (k) at (6,4){estrelles};
		\node (l) at (9,4){complementaris};
		
		\draw (a) edge[->,-latex] (b);
		\draw (f) edge[->,-latex] (a);
		\draw (f) edge[->,-latex] (e);
		\draw (f) edge[->,-latex] (k);
		\draw (g) edge[->,-latex] (f);
		\draw (g) edge[->,-latex] (h);
		\draw (g) edge[->,-latex] (i);
		\draw (g) edge[->,-latex] (b);
		\draw (g) edge[->,-latex] (c);
		\draw (h) edge[->,-latex] (c);
		\draw (h) edge[->,-latex] (d);
		\draw (h) edge[->,-latex] (k);
		\draw (h) edge[->,-latex] (l);
		\draw (j) edge[->,-latex] (g);
		\draw (j) edge[->,-latex] (k);
		\draw (l) edge[->,-latex, bend left=50] (d);
		
		
	\end{tikzpicture}
	\caption{Graf de les dependències de cada apartat}
\end{figure}


\subsubsection{Dijkstra}
Aquest algorisme, desdenvolupat per Edsger W. Dijkstra el 1956, serveix per trobar el camí més curt entre dos nodes d'un gaf ponderat. De fet, això és el que feia la variant original, però la variant presentada aquí troba el camí més curt entre un node inicial i tota la resta de nodes dels graf. Tot i això es pot modificar lleugerament el programa perquè pari quan hagi trobat el camí més curt entre dos nodes especificats. El que fa el programa és suposar quines són les distàncies mínimes des del node inicial fins la resta, i va descobrint el graf fins que pot assegurar el camí més curt. Al principi, suposa que el moviment amb menys cost és no moure's (això serà cert si el graf no conté arestes amb pesos negartius, que l'algorisme no pot tractar). Després busca els nodes adjacents al node inicial, i suposa que les distàncies mínimes entre l'inicial i aquests és simplement l'aresta que els uneix. Es pot assegurar que serà cert pel node unit amb l'aresta de menys pes, per la desigualtat triangular (si s'hi pogués accedir per un altre camí, aquest seria més llarg, ja que per força alguna de les arestes amb més pes que s'han descartat ha de formar part del camí alternatiu, i la suma serà sempre superior). Un cop hi ha el primer node amb mínim pes assegurat (i per tant ja sap un camí), es busquen els seus adjacents, el pes dels quals inicialment és infinit. La suposició del pes equivaldrà a el pes del node d'on venen més el de l'aresta que els uneix, i es canviarà pel pes que tenen si aquest és mes gran que el nou. Ara es torna a agafar el node amb el pes menor (que segur que és el mínim) i es torna a mirar els adjacents i assignar pesos. Quan tots els nodes hagin estat visitats, el pes de cada node serà la distància mínima que s'ha de recòrrer per anar del node inicial fins a aquest.

(Adjuntar esquema de procediment de Dijkstra)

Aquest algorisme, encara que no pot treballar amb pesos negatius és molt útil té una gran quantitat d'aplicacions pràctiques:
\begin{itemize}
\item Navegadors GPS, on les arestes són carrers i carreteres, els nodes cruïlles i els pesos distàncies. S'utilitza l'algorisme de Dijkstra per trobar els camins més curts entre dues destincaions.
\item Problemes de canvis de divisa, on volem trobar la miillor manera de canviar divises i guanyar més diners. Aquí els nodes són les diferents monedes o divises, les arestes les transaccions i els pesos les taxes de canvi. Amb aquest algorisme podem trobar la millor manera de fer els canvis de moneda.
\item Els routers utilitzen l'algorisme per portar-te a través d'internet al servidor desitjat amb la menor cantitat de passos possibles.
\item En robòtica s'utilitza per fer la planificació de moviment del robot. Cada node és una unitat d'espai, i omplint tot l'espai de nodes excepte els obstacles i executant l'algorisme en el graf resultant, s'obté el camí més òptim per arribar a la posició desitjada.
\item En epidemologia es pot utilitzar per modelitzar un grup de persones i els seus familiars per veure qui és més susceptible a emmalaltir. Això també pot funcionar entre ciutats o col·lectius més grans. 
 
\end{itemize}


\begin{algorisme}[H]
\DontPrintSemicolon
\KwData{Un graf ponderat $G$ i un node inicial $s$}
\KwResult{Distància mínima entre $s$ i la resta de nodes del graf, arbre expensiu mínim}
nou diccionari $dist$\;
nou diccionari $Q$\;
\ForEach{node $v$ de $G$}
{
	$Q[v]=\infty$\;
	$dist[v]=\infty$\;
}
$Q[s]=0$\;
\While{$Q$ no estigui buit}
{
	$u=min{valor de Q}$\;
	$dist[u]=Q[u]$\;
	\ForEach{node $v$ adjacent a $u$}
	{
		\If{$v$ existeix dins $Q$}
		{
			
			\If{$Q[v]>Q[u]+w(u,v)$}
			{
				\tcc{$w(u,v)$ és el pes de l'aresta \{$u,v$\}}
				$Q[v]=Q[u]+w(u,v)$\;
			}
		}
	}
	elimina($Q[u]$)\;
}
imprimeix($dist$)
\;
\caption{Dijkstra}
\end{algorisme}

\subsubsection{Bellman-Ford}
Aquest algorisme té un funcionament i utilitats molt seblants a les de l'algorisme de Dijkstra, però té la particularitat de poder tractar sense problemes les arestes amb pesos negatius, mentre que Dijkstra no ho permet. Dijkstra es basa en la desigualtat triangular per tobar el camímés curt, però amb pesos negatius no es pot suposar que la desigualtat triangular es compleixi. A més, permet saber si un graf cinté cicles negatius. Si un camí entre dos nodes conté un cile de pes negatiu, no es pot trobar un camí mínim entre aquests dos nodes. Això es deu a que recorrent aquest cicle sempre es podria escurçar el camí, i llavors el mínim possible seria de $-\infty$.


\begin{algorisme}[H]
\SetKwFunction{Range}{range}%%
\KwData{Un graf ponderat $G$ i un node inicia $s$}
\KwResult{Distància mínima entre $s$ i la resta de nodes del graf, arbre expansiu mínim}
nou diccionari $dist$\;
nou diccionari $anterior$\;
\ForEach{node $v$ de $G$}
{
	$dist[v]=\infty$\;
	$anterior[v]=Nul$\;
}
$dist[s]=0$\;
\For{i in range(0, len(Adj)-1)}
{
	\ForEach{$u$ dins $Adj$}
	{
		\ForEach{$v$ dins $Adj[u]$}
		{
			\If{$dist[v]>dist[u]+w(u,v)$}
			{
				\tcc{$w(u,v)$ és el pes de l'aresta \{$u,v$\}}
				$dist[v]=dist[u]+w(u,v)$\;
			}
		}
	}
}

\ForEach{$u$ dins $Adj$}
	{
		\ForEach{$v$ dins $Adj[u]$}
		{
			\If{$dist[v]>dist[u]+w(u,v)$}
			{
				imprimeix("Hi ha cicles de pesos negatius")\;
				
		}
	}		
}
imprimeix($dist$)\;
imprimeix($anterior$)\;
	
\caption{Bellman-Ford}
\end{algorisme}


\subsubsection{Kruskal}
L'algorisme de Kruskal serveix per trobar un arbre expansiu mínim. Aquest algorisme utilitza una estructura de dades especial, anomenada union-find. Aquesta estructura permet fer tres operacions diferents: crear conjunts (Make Set), determinar a quin conjunt està un element (Find) i unir dos subconjunts en un de nou (Union). L'ús d'aquesta estructura especialitzada fa que en grafs petits o poc densos l'algorisme sigui molt ràpid, però en grafs més grans es relantitzi el procés, siguent més eficient utilitzar altres algorismes en aquest cas. L'algorisme, al principi crea un conjunt per a cada node i ordena les arestes de manera creixent segons elsseu pes. Llavors agafa la primera aresta (la de menys pes), que serà una aresta de l'arbre expansiu mínim, i posa en el mateix conjunt els nodes que unia. Després agafa la següent aresta i repeteix el procediment. 

\begin{algorisme}[H]
\DontPrintSemicolon
\KwData{Un graf $G$ i un node inicial $s$}
\KwResult{Arbre expansiu mínim de $G$}
nova estructura union-find $subgraf$\;
nova llista $arbre$
ordena $G$ per ordre creixent de pesos\;
\ForEach{node $u$ de $G$}
{
	\ForEach{node $v$ adjacent a $u$}
	{
		\If{$subgraf[u] != subgarf[v]$}
		{
			afegeix $(u,v)$ a $arbre$\;
			$union(subgraf[u], subgraf[v])$\;
		}
	}
}
imprimeix($arbre$)\;
\end{algorisme}

\subsubsection{Prim}
L'algorisme de Prim, tal com del de Kruskal, serveix per trobar l'arbre expansiu mínim d'un graf ponderat no dirigit. Aquest algorisme funciona amb diccionaris, estructures de dades més normalitzades que el Union-Find. Com a conseqüència, Prim és més lent en grafs petits, però més ràpid en grafs molt densos. Prim divideix els nodes en dos grups, els que pot arribar amb les arestes de l'arbre que va construïnt i els que encara no. Sempre selecciona l'aresta de menys pes entre les que surten de nodes del primer grup i van a nodes del segon, i afegeix el node final de l'aresta al primer grup. D'aquesta manera obté l'arbre expansiu mínim del graf. Aquest algorisme funciona per grafs connexos, peró executant-lo per a cada node del graf, trobaria el bosc (conjunt d'arbres) mínim d'un graf no connex.
 
\begin{algorisme}[H]
\DontPrintSemicolon
\KwData{Un graf $G$}
\KwResult{Arbre expansiu mínim de $G$}
nou diccionari $anterior$\;
nou diccionari $Q$\;
\ForEach{node $v$ de $G$}
{
	$Q[v]=\infty$\;	
}
$Q[0]=0$\;
\While{$Q$ no estigui buit}
{
	$u=min\{$valor de $Q\}$\;
	\ForEach{node $v$ adjacent a $u$}
	{
		\If{$v$ existeix dins $Q$}
		{
			\If{$Q[v] > w(u,v)$}
			{
				$Q[v]=w(u,v)$\;
				$anterior[v]=0$\;
			}
		}
	}
	elimina($Q[u]$)\;
}
imprimeix($anterior$)\;

\caption{Prim}
\end{algorisme}

Tant l'algorisme de Kruskal com del de Prim tenen aplicacions semblants, però segons la mida del graf és més convenient utilitzar-ne un o altre. Entre les aplicacions d'aquests dos algorismes hi ha:
\begin{itemize}
\item S'utilitzen per dissenyar xarxes de telèfon, aigua, gas, internet... En aquestes xarxes s'ha d'arribar a tots els punts on s'ha de fer la distribució, i amb l'arbre expansiu mínim es pot assegurar que la xarxa és el més curta possible.
\item Els arbres expansius mínims es poden utilitzar per generar laberints.
\item S'utilitzen com a subrutines (o funcions) d'algorismes més complexes.
\end{itemize}

\subsubsection{Floyd-Warshall}
L'algorisme de Floyd-Warshall és un algorisme que permet calcular les distàncies entre tots els nodes d'un graf ponderat. Per fer-ho, compara els pesos de tots els camins possibles. A cada iteració, es defineix el conjunt de nodes que pot tenir cada camí i si ja s'ha trobat un camí amb els mateixos extrems es compara el pes total d'ambdós . El conjunt és de la forma ${1,2,\cdots,k}$ i a cada iteració es va incrememntant $k$ (a l'inici $k=0$). El resultat d'aquest algorisme és una matriu quadrada $D$ de $|V|$x$|v|$ on $D_{i,j}=w(i,j)$.

Aquest algorisme es pot utilitzar per qualsevol de les aplicacions en que s'utilitzaria Dijkstra en més d'un node. S'utilitza sobretot quan es vol mantenir una base de dades de pesos precalculats, per no haver d'executar Dijkstra en cada cas concret. 
A part d'aquesta aplicació, s'utilitza també d'altres maneres:
\begin{itemize}
\item Per detectar cicles de pes negatiu, cosa que passarà quan $D_{i,i} < 0$, quan a la diagonal de la matriu hi hagi un valor negatiu. 
\item Estudiar la clausura transitiva d'un graf, és a dir, veure quins nodes són accessibles des de cada node. Això es pot veure a la matriu resultant, on els valors $\infty$ indiquen que no espot accedir a el node concret.
\end{itemize}


\begin{algorisme}[H]
\DontPrintSemicolon
\KwData{un graf $G$}
\KwResult{una matriu quadrada amb les distàncies entre tots els nodes}
nova matriu $dist$ de $|V|x|V|$\;
\For{$i$ in range($0, |V|$)}
{
	\For{$j$ in range($0, |V|$)}
	{
		\uIf{$i = j$}
		{
			$dist[i][j]=0$\;
		}
		\Else
		{
			$dist[i][j]=\infty$\;
		}
	}
}
\ForEach{node $u$ de $G$}
{
	\ForEach{node $v$ adjacent a $u$}
	{
		$dist[u][v]=w(u,v)$\;
	}
}
\For{$x$ in range($0, |V|$)}
{
	\For{$u$ in range($0, |V|$)}
	{
		\For{$v$ in range($0, |V|$)}
		{
			\If{$dist[u][v] > dist[u][x] + dist[x][v]$}
			{
				$dist[u][v] = dist[u][x] + dist[x][v]$\;
			}
		}
	}
}
\caption{Floyd-Warshall}
\end{algorisme}
 

\part{Disseny de grafs}
Fins ara, s'han mostrat i estudiat grafs que ja estan definits i que s'ha de fer alguna sobre ells. Ara bé, en aplicacions reals de teoria de grafs, sovint no hi ha un graf determinat, sinó que s'ha de generar.  

\section{Punt de Fermat i l'arbre de Steiner}
Normalment, els nodes ja estaran determinats i el problema consistirà en trobar les arestes.
Si aquest és així, segurament es podràn afegir altres nodes. Un exemple d'aquest cas consistiria en haver d'unir tres ciutats amb carreteres de tal manera que des d'una es pugui arribar directament a les altres dues. La primera sol·lució en que sol pensar una persona és fer un triangle en el qual les ciutats siguin els vèrtexs (l'equivalent a un graf $K_{3}$). Aquesta sol·lució és òptima si es vol anar d'una ciutat a l'altre amb la mínima distància possible, però si es vol construïr el mínim de carreteres possibles, aquesta sol·lució no és la millor. En aquest cas, el millor és posar un altre node en el punt de Fermat del triangle que formen i obtenir un graf $S_{4}$.
El punt de Fermat, també anomenat $X(13)$, és el punt del triangle tal que la suma de les distàncies des de cada vèrtex fins a aquest punt és la mínima. El punt de Fermat s'aconsegueix amb el procediment següent:
\begin{itemize}
\item Donat un triangle $T$, es generen dos triangles equlàters a partir de dos costats arbitraris de $T$.
\item S'uneixen els nous vèrtexs dels triangles equilàters amb els vèrtexs oposats a $T$.
\item L'intersecció d'aquests dos segments dona la posició del punt de Fermat.
\end{itemize}
(adjuntar imatge de punt de fermat)
Aquest procediment és vàlid per a triangles amb angles menors a $120º$, però en cas contrari, el punt de Fermat serà l'angle que els superi.

El punt de Fermat es pot generalitzar per a altres polígons convexos a partir de triangulacions d'aquests. Un exemple senzill és el del quadrilàter, on en fer les diagonals ja es generen quatre triangles. En aquest cas, trobant els punts en dos dels triangles i unint-los ja s'uneixen tots els punts amb la menor distància possible. 
(adjuntar imatge del punt de fermat en quadrilàters i superiors)

El problema de connectar amb la mínima distància un nombre determinat de punts siguent possible aferigir nodes és conegut com el problema de l'arbre de Steiner. Per aquest problema s'ha demostrat que en l'arbre òptim té com a màxim $n-2$ nodes afegits (siguent $n$ el nombre inicial de nodes), que aquests tenen sempre grau $3$, i que formen sempre angles de $120º$.   

\section{Arbres expansius}
Quan hi ha una situació on no es pot afegir cap node, el millor sol ser utilitzar els algorismes per trobar arbres expansius que ja s'han vist. Una opció és construïr el graf complet amb totesles arestes i els seus corresponents pesos i executar algun algorisme que en trobi l'arbre expansiu mínim. 
\\


\part{Topologia}

La topologia és la branca de les matemàtiques que estudia les propietats de l'espai i si aquestes es conserven després de deformacions. Des d'un punt de vista teòric, 

\section{Isomorfismes}

Es diu que dos grafs són isomorfs si existeix una funció bijectiva $\varphi$ entre els seus vèrtexs que conservi les arestes. Formalment dos grafs $G$ i $H$ són isomorfs si

\[\exists\varphi:V(G)\rightarrow V(H) \text{ tal que } \overline{\varphi(v)\varphi(u)}\in E(H) \text{ si i només si } \overline{vu}\in E(G)\]

\begin{figure}[H]
\centering
	\subfloat{
		\begin{tikzpicture}[round/.style={circle, text=white, thin, minimum size=.5mm}, transform shape, scale=0.80]
			\node[round, fill=blue] (a) at (0,0){2};
			\node[round, fill=red] (b) at (4,0){0};
			\node[round, fill=green] (c) at (2,1.5){3};
			\node[round, fill=purple] (d) at (2,4){1};
			\draw (a) edge (b);
			\draw (a) edge (c);
			\draw (a) edge (d);
			\draw (b) edge (c);
			\draw (b) edge (d);
			\draw (c) edge (d);
		\end{tikzpicture}
	}
	\subfloat{
		\begin{tikzpicture}[round/.style={circle, text=white, thin, minimum size=.5mm}, transform shape, scale=0.80]
			\node[round, fill=blue] (a) at (0,0){c};
			\node[round, fill=red] (b) at (4,0){a};
			\node[round, fill=green] (c) at (0,4){d};
			\node[round, fill=purple] (d) at (4,4){b};
			\draw (a) edge (b);
			\draw (a) edge (c);
			\draw (a) edge (d);
			\draw (b) edge (c);
			\draw (b) edge (d);
			\draw (c) edge (d);
		\end{tikzpicture}
	}
	\caption{Grafs isomorfs}
\end{figure}




 


\end{document}
